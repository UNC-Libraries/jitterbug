<?php namespace Jitterbug\Presenters;

use DB;
use Log;

use Illuminate\Support\Collection;

use Venturecraft\Revisionable\Revision;

use Jitterbug\Models\AudioVisualItem;

/**
 * Analyzes and summarizes a revision transaction and compiles a
 * list of activities to be displayed in the activity stream module 
 * of the dashboard.
 */
class TransactionDigest
{

  /**
   * The base model classes in Jitterbug that we track revisions
   * for that don't have a 'parent' Jitterbug class. This array is used
   * in analyzing the revisions.
   *
   * @var array
   */
  protected $baseClasses = array('AudioVisualItem' => 1,
                                 'PreservationMaster' => 1,
                                 'Transfer' => 1,
                                 'Cut' => 1);
  
  /**
   * The classes invovled in the import of audio records. We use this
   * array as a way to identify after-the-fact that a transaction was
   * for the import of audio records. 
   *
   * @var array
   */
  protected $audioImportClasses = array('PreservationMaster' => 1,
                                        'Transfer' => 1,
                                        'Cut' => 1);

  /**
   * The classes invovled in the import of video records. We use this
   * array as a way to identify after-the-fact that a transaction was
   * for the import of video records. 
   *
   * @var array
   */
  protected $videoImportClasses = array('VideoMaster' => 1,
                                        'VideoTransfer' => 1);

  /**
   * The activites, generated by this class from analyzing the revisions
   * of the transaction.
   *
   * @var array
   */
  protected $activities = null;

  /**
   * The UUID for this transaction.
   *
   * @var string
   */
  protected $transactionId = null;

  /**
   * The revisions involved in this transaction.
   *
   * @var Illuminate\Support\Collection
   */
  protected $revisions = null;

  /**
   * The action of the transaction (created, updated, deleted, 
   * or imported), determined by the analyzeRevisions() function.
   *
   * @var string
   */
  protected $action = null;

  /**
   * If this transaction was an import, the type of import
   * (audio, film, or video).
   *
   * @var string
   */
  protected $importType = null;

  /**
   * Whether or not the transaction was a batch operation,
   * determined by the analyzeRevisions() function.
   * 
   * @var boolean
   */
  protected $batch = null;

  /**
   * The number of objects that were selected for batch modification
   * by the user.
   * 
   * @var int
   */
  protected $batchSize = null;

  /**
   * The number of revisionable records affected by the transaction.
   *
   * @var int
   */
  protected $numAffected = null;

  /**
   * The AudioVisualItem associated with this transaction, if it's not a
   * batch transaction (which might be associated with multiple items).
   *
   * @var AudioVisualItem
   */
  protected $associatedItem = null;

  /**
   * The call number associated with the transaction, if it's not a batch 
   * transaction (which might be associated with multiple call numbers).
   *
   * @var string
   */
  protected $associatedCallNumber = null;

  /**
   * The type of the item that is ultimately associated with this transaction,
   * if it's not batch.
   *
   * @var string
   */
  protected $associatedItemType = null;

  /**
   * The types of objects (audio item, film item, video item, audio master, 
   * etc.) affected by the transaction mapped to ids of objects affected.
   *
   * @var array
   */
  protected $objectTypesToIds = null;

  /**
   * The unique revisionable types involved in the transaction.
   */
  protected $uniqueRevisionableTypes = null;

  /**
   * Create a new instance.
   *
   * @return void
   */
  public function __construct($transactionId)
  {
    $this->transactionId = $transactionId;
    // Order revisions by most recent, which is important for analysis
    $this->revisions = Revision::where('transaction_id', $transactionId)
                                     ->orderBy('id', 'desc')
                                     ->get();
    $this->analyzeRevisions();
    $this->generateActivities();
  }

  /**
   * Return the generated activities.
   *
   * @return array
   */
  public function activities()
  {
    return $this->activities;
  }

  /**
   * Perform the analysis of the transaction revisions to determine
   * the action that took place, and to what objects. 
   */
  private function analyzeRevisions()
  {
    $this->buildObjectTypesToIds();

    if ($this->wasCreate()) {
      $this->action = 'created';
    } else if ($this->wasUpdate()) {
      $this->action = 'updated';
    } else if ($this->wasDelete()) {
      $this->action = 'deleted';
    }

    if ($this->wasAudioImport()) {
      $this->action = 'imported';
      $this->importType = 'audio';
      $this->batch = true;
      $this->batchSize = $this->computeImportSize();
    } else if ($this->wasVideoImport()) {
      $this->action = 'imported';
      $this->importType = 'video';
      $this->batch = true;
      $this->batchSize = $this->computeImportSize();
    }

    if ($this->action === null) {
      throw new \Exception('Unrecognized transaction type: ' 
        . $this->transactionId);
    }

    if ($this->batch === null && $this->wasBatch()) {
      $this->batch = true;
    } else if ($this->batch === null) {
      $this->batch = false;
    }

    // If this is not a batch operation, find the call number
    // and item type it relates to.
    if (!$this->batch) {
      $this->findAssociatedCallNumber();
      $this->findAssociatedItemType();
    }

    $this->computeNumAffected();
  }

  
  /**
   * Create the activities associated with this transaction. Assumes 
   * the analyzeRevisions() function has already been called. 
   *
   * @return void
   */
  private function generateActivities()
  {
    $this->activities = array();

    // Populate a new activity with the base attributes
    $activity = new Activity;
    $activity->transactionId = $this->transactionId;
    $activity->action = $this->action;
    $activity->batch = $this->batch;
    $activity->batchSize = $this->batchSize;
    $activity->numAffected = $this->numAffected;
    $activity->timestamp = 
      timeAgoInWords($this->revisions->first()->created_at);
    $activity->user = $this->getUserResponsibleName();
    // If batch, itemCallNumber & itemType will be null
    $activity->itemCallNumber = $this->associatedCallNumber;
    $activity->itemType = $this->associatedItemType;
    $activity->importType = $this->importType;

    // If this is an update where the call number was updated, let's filter
    // out revisions and object types that aren't audio visual item call 
    // number updates.
    if ($this->action === 'updated' 
                           && !$this->batch && $this->callNumberUpdated()) {
      foreach ($this->revisions as $key => $revision) {
        if ($revision->field === 'call_number' 
          && $revision->revisionable_type !== 'AudioVisualItem') {
          $this->revisions->forget($key); 
        }
      }
     
      foreach ($this->objectTypesToIds as $key => $ids) {
        if (!ends_with($key, 'item')) {
          unset($this->objectTypesToIds[$key]);
        }
      }
    }

    $activity->objectTypesToIds = $this->objectTypesToIds;

    // Since this is a regular update, each revision will
    // be for an individual field. If there are just a handfull
    // of fields, we will create activities for each revision.
    // If there are more than a handfull, we'll create 1 activity
    // to summarize so as not to fill up the user's activity
    // stream with a single transaction.
    if ($this->action === 'updated' 
                           && !$this->batch && $this->revisions->count() < 4) {
      foreach ($this->revisions as $revision) {
        $updateActivity = clone $activity;
        $updateActivity->field = $revision->fieldName();
        array_push($this->activities, $updateActivity);
      }
      return;
    } else if ($this->action === 'updated' && !$this->batch) {
      $activity->numFields = $this->revisions->count();
    }

    array_push($this->activities, $activity);
  }

  /**
   * Test whether or not a call number was updated.
   */
  private function callNumberUpdated()
  {
    foreach ($this->revisions as $revision) {
      if ($revision->field === 'call_number') {
        return true;
      }
    }
    return false;
  }

  /**
   * Return the name of the user that carried out the transaction.
   *
   * @return string
   */
  private function getUserResponsibleName()
  {
    $firstRev = $this->revisions->first();
    return $firstRev->userResponsible()->fullName();
  }

  /**
   * Every object that we keep revisions for is ultimately associated
   * with an audio visual item, unless it's been orphaned. This 
   * function returns said item.
   *
   * @return string
   */
  private function findAssociatedItem()
  {
    if ($this->associatedItem) return $this->associatedItem;
    if ($this->batch) return null;
    $firstRev = $this->revisions->first();
    $class = $firstRev->revisionable_type;
    $instance = 
      $class::withTrashed()->findOrFail($firstRev->revisionable_id);
    if (!array_key_exists($firstRev->revisionable_type, $this->baseClasses)) {
      $instance = $instance->superclass;
    }
    $this->associatedItem = AudioVisualItem::withTrashed()
      ->where('call_number', $instance->callNumber)
      ->first();
    return $this->associatedItem;
  }

  /**
   * Every object that we keep revisions for is ultimately associated
   * with an audio visual item. This function returns the type of this 
   * item (audio, film, or video).
   *
   * @return string
   */
  private function findAssociatedItemType()
  {
    if ($this->associatedItemType) return $this->associatedItemType;
    $item = AudioVisualItem::withTrashed()
      ->where('call_number', $this->findAssociatedCallNumber())
      ->first();
    if ($item !== null) {
      $this->associatedItem = $item;
      $this->associatedItemType = strtolower($item->type);
    }
    return $this->associatedItemType;
  }

  /**
   * Get the call number from the referenced object (item, master, transfer
   * or cut) in the first revision.
   *
   * @return string
   */
  private function findAssociatedCallNumber()
  {
    if ($this->associatedCallNumber) return $this->associatedCallNumber;
    $firstRev = $this->revisions->first();
    $class = $firstRev->revisionable_type;
    $instance = 
      $class::withTrashed()->findOrFail($firstRev->revisionable_id);
    if (!array_key_exists($firstRev->revisionable_type, $this->baseClasses)) {
      $instance = $instance->superclass;
    }
    $this->associatedCallNumber = $instance->callNumber;
    return $instance->callNumber;
  }

  /**
   * Determine if this transaction was for creating records.
   *
   * @return boolean
   */
  private function wasCreate()
  {
    foreach ($this->revisions as $revision) {
      if ($revision->field !== 'created_at') {
        return false;
      }
    }
    return true;
  }

  /**
   * Determine if this transaction was for updating records.
   *
   * @return boolean
   */
  private function wasUpdate()
  {
    foreach ($this->revisions as $revision) {
      if ($revision->field === 'created_at' ||
          $revision->field === 'deleted_at') {
        return false;
      }
    }
    return true;
  }

  /**
   * Determine if this transaction was for deleting records.
   *
   * @return boolean
   */
  private function wasDelete()
  {
    foreach ($this->revisions as $revision) {
      if ($revision->field !== 'deleted_at') {
        return false;
      }
    }
    return true;
  }

  /**
   * Determine if this transaction was for importing audio records,
   * which is done by checking the revisionable types of the revisions
   * for the presence of preservation masters, transfers and cuts.
   *
   * @return boolean
   */
  private function wasAudioImport()
  {
    if ($this->action === 'deleted') {
      return false;
    }

    $types = $this->uniqueRevisionableTypes();
    if (array_key_exists('AudioVisualItem', $types)) {
      return false;
    }

    return !array_diff(array_keys($this->audioImportClasses), 
                       array_keys($types));
  }

  /**
   * Determine if this transaction was for importing video records,
   * which is done by checking the revisionable types of the revisions
   * for the presence of video masters and video transfers.
   *
   * @return boolean
   */
  private function wasVideoImport()
  {
    if ($this->action === 'deleted') {
      return false;
    }

    $types = $this->uniqueRevisionableTypes();
    if (array_key_exists('AudioVisualItem', $types)) {
      return false;
    }

    return !array_diff(array_keys($this->videoImportClasses), 
                       array_keys($types));
  }

  /**
   * Computes the number of records that were in the batch import.
   */
  private function computeImportSize()
  {
    if ($this->batchSize) return $this->batchSize;
    // Since this is an import, we can just count the number of unique
    // preservation master revisions.
    $ids = array();
    foreach ($this->revisions as $revision) {
      if ($revision->revisionable_type === 'PreservationMaster') {
        $ids[$revision->revisionable_id] = 1;
      }
    }
    $this->batchSize = count($ids);
    return $this->batchSize;
  }

  /**
   * Determine if this transaction was a regular batch operation (i.e.
   * a batch but not an import).
   *
   * @return boolean
   */
  private function wasBatch()
  {
    $totalItems = 0;
    $totalMasters = 0;
    $totalTransfers = 0;
    
    // Total up the number of ids affected for each object type.
    // We can use these totals to determine which object type
    // the batch operation originated from. For exampple, if 
    // there are items in the array, the transaction originated
    // from items, and if multiple items were involved, then it
    // was batch. Likewise, if there are masters in the map but 
    // no items, the operation originated from masters. If there
    // was more than one master involved, it was batch, and so on.
    foreach ($this->objectTypesToIds as $key => $value) {
      if (ends_with($key, 'item')) {
        $totalItems = $totalItems + count($value);
      } else if (ends_with($key, 'master')) {
        $totalMasters = $totalMasters + count($value);
      } else if (ends_with($key, 'transfer')) {
        $totalTransfers = $totalTransfers + count($value);
      }
    }

    if ($totalItems > 1) {
      $this->batchSize = $totalItems;
      return true;
    } else if ($totalMasters > 1 && $totalItems === 0) {
      $this->batchSize = $totalMasters;
      return true;
    } else if ($totalTransfers > 1 && $totalMasters === 0) {
      $this->batchSize = $totalTransfers;
      return true;
    }

    return false;
  }

  /**
   * Find the unqiue revisionable types in the revisions.
   *
   * @return array
   */
  private function uniqueRevisionableTypes()
  {
    if ($this->uniqueRevisionableTypes !== null) {
      return $this->uniqueRevisionableTypes;
    }

    $types = array();
    foreach ($this->revisions as $revision) {
      $types[$revision->revisionable_type] = 1;
    }

    $this->uniqueRevisionableTypes = $types;

    return $types;
  }

  /**
   * Iterates through the revisions in this transaction, finding the object types
   * that were modified in the transaction, along with the ids that were modified.
   * Returns an array of object types with each type mapped to an array of ids.
   *
   * @return array
   */
  private function buildObjectTypesToIds()
  {
    if ($this->objectTypesToIds !== null) return $this->objectTypesToIds;

    $typesToIds = array();
    foreach ($this->revisions as $revision) {
      $class = $revision->revisionable_type;
      $instance = 
          $class::withTrashed()->findOrFail($revision->revisionable_id);
      $id = $revision->revisionable_id;

      if (!array_key_exists($revision->revisionable_type, $this->baseClasses)) {
        // This will also result in a db query.
        $instance = $instance->superclass;
        $class = class_basename(get_class($instance));
        $id = $instance->id;
      }

      // e.g. convert 'AudioVisualItem' to 'audio_visual_item'
      $snakeClass = snake_case($class);
      $explodedClass = explode('_', $snakeClass);
      // We have a base class instance, so get the subclass type 
      // ('audio', 'film' or 'video')
      $type = $snakeClass === 'cut' ? '' : strtolower($instance->type);
      // e.g. results in: 'audio item'
      $displayClass = trim($type . ' ' . array_pop($explodedClass));
      $exists = $instance->deletedAt === null;
      if (!isset($typesToIds[$displayClass])) {
        $typesToIds[$displayClass] = array($id => $exists);
      } else {
        $typesToIds[$displayClass][$id] = $exists;
      }
    }
    $this->objectTypesToIds = $typesToIds;
    return $this->objectTypesToIds;
  }

  /**
   * Get the number of records (items, masters or transfers) involved in
   * this transaction.
   *
   * @return int
   */
  private function computeNumAffected()
  {
    if ($this->numAffected) return $this->numAffected;

    $total = 0;
    foreach ($this->objectTypesToIds as $type => $ids) {
      $total = $total + count($ids);
    }
    $this->numAffected = $total;

    return $this->numAffected;
  }
}

